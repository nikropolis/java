package app;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

/**
 * A quick and dirty example of query DNS A record and log response.
 * This code has no error handling.
 *
 */

public class DNSClient {
    private static final String DNS_SERVER_ADDRESS = "8.8.8.8";
    private static final int DNS_SERVER_PORT = 53;

    
    public static String magic(String domain) throws IOException {
        String result = "";
        InetAddress ipAddress = InetAddress.getByName(DNS_SERVER_ADDRESS);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(baos);

        // *** Build a DNS Request Frame ****

        // Identifier: A 16-bit identification field generated by the device that creates the DNS query. 
        // It is copied by the server into the response, so it can be used by that device to match that 
        // query to the corresponding reply received from a DNS server. This is used in a manner similar 
        // to how the Identifier field is used in many of the ICMP message types.
        dos.writeShort(0x1234);

        // Write Query Flags
        dos.writeShort(0x0100);

        // Question Count: Specifies the number of questions in the Question section of the message.
        dos.writeShort(0x0001);

        // Answer Record Count: Specifies the number of resource records in the Answer section of the message.
        dos.writeShort(0x0000);

        // Authority Record Count: Specifies the number of resource records in the Authority section of 
        // the message. (“NS” stands for “name server”)
        dos.writeShort(0x0000);

        // Additional Record Count: Specifies the number of resource records in the Additional section of the message.
        dos.writeShort(0x0000);

        // TODO: write query
        String[] domainParts = domain.split("\\.");
        result += (domain + " has " + domainParts.length + " parts"+'\n');

        for (int i = 0; i<domainParts.length; i++) {
        	result += ("Writing: " + domainParts[i]+'\n');
            byte[] domainBytes = domainParts[i].getBytes("UTF-8");
            dos.writeByte(domainBytes.length);
            dos.write(domainBytes);
        }

        // No more parts
        dos.writeByte(0x00);

        // Type 0x01 = A (Host Request)
        dos.writeShort(0x0001);

        // Class 0x01 = IN
        dos.writeShort(0x0001);

        byte[] dnsFrame = baos.toByteArray();

        result += ("Sending: " + dnsFrame.length + " bytes"+'\n');
        for (int i =0; i< dnsFrame.length; i++) {
        	result += ("0x" + String.format("%x", dnsFrame[i]) + " " );
        }

        // *** Send DNS Request Frame ***
        DatagramSocket socket = new DatagramSocket();
        DatagramPacket dnsReqPacket = new DatagramPacket(dnsFrame, dnsFrame.length, ipAddress, DNS_SERVER_PORT);
        socket.send(dnsReqPacket);

        // Await response from DNS server
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);
        socket.receive(packet);

        result += ("\n\nReceived: " + packet.getLength() + " bytes"+'\n');

        for (int i = 0; i < packet.getLength(); i++) {
        	result += (" 0x" + String.format("%x", buf[i]) + " " );
        }
        result += ("\n");


        DataInputStream din = new DataInputStream(new ByteArrayInputStream(buf));
        result += ("Transaction ID: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("Flags: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("Questions: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("Answers RRs: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("Authority RRs: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("Additional RRs: 0x" + String.format("%x", din.readShort())+'\n');

        int recLen = 0;
        while ((recLen = din.readByte()) > 0) {
            byte[] record = new byte[recLen];

            for (int i = 0; i < recLen; i++) {
                record[i] = din.readByte();
            }
            
            result += ("Record: " + new String(record, "UTF-8")+'\n');
        }

        result += ("Record Type: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("Class: 0x" + String.format("%x", din.readShort())+'\n');

        result += ("Field: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("Type: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("Class: 0x" + String.format("%x", din.readShort())+'\n');
        result += ("TTL: 0x" + String.format("%x", din.readInt())+'\n');

        short addrLen = din.readShort();
        result += ("Len: 0x" + String.format("%x", addrLen)+'\n');

        result += ("Address: ");
        for (int i = 0; i < addrLen; i++ ) {
        	result += ("" + String.format("%d", (din.readByte() & 0xFF)));
        	if(i < addrLen-1)
        		result += ".";
        }
        
        return result;
    }

}
